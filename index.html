<!DOCTYPE html>
<html lang="en">


<head>
  <meta charset="UTF-8">
  <title>CryptoZombies front-end</title>
  <link rel="icon" href="favicon.ico">
  <script language="javascript" type="text/javascript"
    src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script language="javascript" type="text/javascript"
    src="https://cdnjs.cloudflare.com/ajax/libs/web3/1.2.7-rc.0/web3.min.js"></script>
  <script language="javascript" type="text/javascript" src="cryptozombies_abi.js"></script>
  <link rel="stylesheet" href="./style.css">
</head>

<body>
  <h1>Welcome to cryptozombie</h1>
  <div id="txStatus"></div>
  <div id="zombies"></div>
  <div class="AllButtons" style="
    height: 100px;
    width: 1100px;">
    <button class="showZombieButton">Show Zombies</button>
    <button class="createzombieButton">Create Zombie</button>
    <button class="levelupButton">Level Up</button>
    <button class="deleteZombieButton">Delete Zombie</button>

    <button class="createmultipleZombieButton">Create Multiple Zombies</button>
    <button class="showNft" onclick="marketnfts()">Show NFT</button>
  </div><div>
    <select class="recipientDropdown">
      <option value="">-- Select an Account --</option>
    </select>
    <button class="transferZombieButton">Transfer</button>


  </div>

  <div id="zombies">
    <!-- Dynamically populated list of zombies -->
  </div>

  <div id="marketplace">
    <!-- Dynamically populated marketplace for buying other zombies -->
  </div>


  <script>

    var cryptoZombies;
    var userAccount;
    const showZombieButton = document.querySelector('.showZombieButton');
    const createzombieButton = document.querySelector('.createzombieButton');
    const levelupButton = document.querySelector('.levelupButton');
    const deleteZombieButton = document.querySelector('.deleteZombieButton'); // Add a new button for deletion
    const createmultipleZombieButton = document.querySelector('.createmultipleZombieButton');
    const showNft = document.querySelector('.showNft');

    async function fetchSecrets() {
      try {
        const response = await fetch('build/contracts/ZombieOwnership.json');
        const secrets = await response.json();
        return secrets;
      } catch (error) {
        console.error('Error fetching secrets:', error);
        return null;
      }
    }

    async function startApp() {

      //ZombieOwnership contratc address
      var cryptoZombiesAddress = "";

      const secrets = await fetchSecrets();
      if (secrets && secrets.networks && secrets.networks['5777']) {
        console.log("Key retrieved is " + secrets.networks[5777].address);
        cryptoZombiesAddress = secrets.networks[5777].address;
      } else {
        console.log("Address not found in the provided JSON.");
      }

      cryptoZombies = new web3.eth.Contract(cryptoZombiesABI, cryptoZombiesAddress);


      //the following code from Lesson 6, chapter 5 is obsolete
      //     var accountInterval = setInterval(function () {

      //      if (web3.eth.accounts[0] !== userAccount) {
      //userAccount = web3.eth.accounts[0];

      //     getZombiesByOwner(userAccount)
      //      .then(displayZombies);
      //  }
      // }, 100);

      cryptoZombies.events.Transfer({ filter: { _to: userAccount } })
        .on("data", function (event) {
          let data = event.returnValues;
          getZombiesByOwner(userAccount).then(displayZombies);
        }).on("error", console.error);
    }

    function displayZombies(ids) {
      $("#zombies").empty();
      for (let id of ids) {
        getZombieDetails(id).then((zombie) => {
          let imageUrl = `https://robohash.org/${zombie.dna}?set=set1&size=150x150`;
          $("#zombies").append(`
                <div class="zombie">
                    <input type="checkbox" class="zombieCheckbox" value="${id}" data-id="${id}">
                    <ul>
                        <li><img src="${imageUrl}"/></li>
                        <li>Name: ${zombie.name}</li>
                        <li>DNA: ${zombie.dna}</li>
                        <li>Level: ${zombie.level}</li>
                        <li>Wins: ${zombie.winCount}</li>
                        <li>Losses: ${zombie.lossCount}</li>
                        <li>Ready Time: ${zombie.readyTime}</li>
                    </ul>
                    <input type="text" class="zombieNameInput" placeholder="New Name">
                    <button class="changeNameButton" data-id="${id}" level-id="${zombie.level}">Change Name</button>
                    

                    <!-- Add the "List on NFT" Button -->
                    <button class="listOnNftButton" data-id="${id}" data-name="${zombie.name}" >List on NFT</button>
                    <button class="cancelOnNftButton" data-id="${id}" data-name="${zombie.name}" >Cancel on NFT</button>
                    <button class="changeDnaButton" data-id="${id}" level-id="${zombie.level}" onclick="changeDnaButtons(${id}, ${zombie.level})">Change DNA</button>
                </div>
            `);
        });
      }

    }

    // Function to list zombie for sale
    async function listZombieForSale(zombieId, price) {
      const pricetowei = web3.utils.toWei(price.toString(), "ether");
      try {

        // Call the smart contract method to list the zombie
        await cryptoZombies.methods.listZombieForSale(zombieId, pricetowei)
          .send({ from: userAccount })
          .on("receipt", function (receipt) {
            console.log("Zombie listed for sale!", receipt);
          })
          .on("error", function (error) {
            console.error("Failed to list zombie for sale:", error);
          });

        alert(`Zombie ${zombieId} listed for sale at ${price} ETH.`);
      } catch (error) {
        console.error("Error listing zombie for sale: ", error.message);
        alert("Error listing zombie for sale.");
      }
    }


    $(document).on('click', '.listOnNftButton', function () {
      const zombieId = $(this).attr("data-id");
      const zombieName = $(this).attr("data-name");

      const price = prompt(`Enter the price in ETH to list ${zombieName} for sale:`);

      if (price && price > 0) {
        listZombieForSale(zombieId, price);
      } else {
        alert("Please enter a valid price.");
      }
    });

    $(document).on('click', '.cancelOnNftButton', async function () {
      const zombieId = $(this).attr("data-id");
      
      await cryptoZombies.methods.cancelZombieSale(zombieId)
          .send({ from: userAccount })
          .on("receipt", function (receipt) {
            console.log("Zombie canceled for sale!", receipt);
          })
          .on("error", function (error) {
            console.error("Failed to canceled zombie for sale:", error);
          });
    });


    $(document).on('click', '.changeNameButton', function () {
      const zombieId = $(this).attr("data-id");
      const newName = $(this).siblings(".zombieNameInput").val().trim();

      if (!newName) {
        $("#txStatus").text("Please enter a valid name.");
        return;
      }

      changeZombieName(zombieId, newName);
    });

    function changeDnaButtons(zombieId, zombielevel) {

      // const zombieId = $(this).attr("data-id");
      // const zombielevel = $(this).attr("level-id");
      debugger;
      // Disable the button after it is clicked to prevent multiple submissions
      $(this).prop('disabled', true);
      $(this).text('Changing DNA...');

      const newDna = Math.floor(Math.random() * 999999);
      const newDnaValue = newDna * 100;

      //const zombie =  getZombieDetails(zombieId);

      if (zombielevel < 20) {
        $("#txStatus").text("You can only change DNA for zombies at level 20 or above.");
        // Re-enable the button after the operation
        $(this).prop('disabled', false);
        $(this).text('Change DNA');
        return;
      }

      $("#txStatus").text("Changing DNA...");

      // Call the changeZombieDna function to perform the transaction
      try {
        return cryptoZombies.methods.changeDna(zombieId, newDnaValue)
          .send({ from: userAccount })
          .on("receipt", function (receipt) {
            $("#txStatus").text("Zombie DNA changed successfully!");
            getZombiesByOwner(userAccount).then(displayZombies);
          })
          .on("error", function (error) {
            $("#txStatus").text(error);
          });
        // // Successfully changed DNA
        // $(this).text('DNA Changed');
      } catch (error) {
        $("#txStatus").text("Error changing DNA.");
        // Re-enable the button in case of error
        $(this).prop('disabled', false);
        $(this).text('Change DNA');
      }

    }






    function createRandomZombie(name) {


      $("#txStatus").text("Creating new zombie on the blockchain. This may take a while...");

      return cryptoZombies.methods.createRandomZombie(name)
        .send({ from: userAccount })
        .on("receipt", function (receipt) {
          $("#txStatus").text("Successfully created " + name + "!");

          getZombiesByOwner(userAccount).then(displayZombies);
        })
        .on("error", function (error) {

          $("#txStatus").text(error);
        });
    }

    function createMultipleZombie(name, count) {
      $("#txStatus").text("Creating multiple zombies on the blockchain. This may take a while...");
      for (let i = 0; i < count; i++) {
        name = name + i;
        cryptoZombies.methods.createMultipleZombies(name)  // Pass only the 'name' parameter
          .send({ from: userAccount })
          .on("receipt", function (receipt) {
            $("#txStatus").text("Successfully created " + name + "!");
            getZombiesByOwner(userAccount).then(displayZombies);
          })
          .on("error", function (error) {
            $("#txStatus").text(error);
          });
      }
    }


    function feedOnKitty(zombieId, kittyId) {
      $("#txStatus").text("Eating a kitty. This may take a while...");
      return cryptoZombies.methods.feedOnKitty(zombieId, kittyId)
        .send({ from: userAccount })
        .on("receipt", function (receipt) {
          $("#txStatus").text("Ate a kitty and spawned a new Zombie!");
          getZombiesByOwner(userAccount).then(displayZombies);
        })
        .on("error", function (error) {
          $("#txStatus").text(error);
        });
    }

    function levelUp(zombieId) {
      $("#txStatus").text("Leveling up your zombie...");
      return cryptoZombies.methods.levelUp(zombieId)
        .send({ from: userAccount, value: web3.utils.toWei("0.001", "ether") })
        .on("receipt", function (receipt) {
          $("#txStatus").text("Power overwhelming! Zombie successfully leveled up");
        })
        .on("error", function (error) {
          $("#txStatus").text(error);
        });
    }

    async function changeZombieDna(zombieId, newDna) {
      $("#txStatus").text("Changing DNA...");

      // Fetch the zombie details
      const zombie = await getZombieDetails(zombieId);

      // Check if the zombie's level is less than 20
      if (zombie.level < 20) {
        $("#txStatus").text("You can only change DNA for zombies at level 20 or above.");
        return;  // Exit the function early
      }

      // Proceed with the DNA change if the level is sufficient
      return cryptoZombies.methods.changeDna(zombieId, newDna)
        .send({ from: userAccount })
        .on("receipt", function (receipt) {
          $("#txStatus").text("Zombie DNA changed successfully!");
          getZombiesByOwner(userAccount).then(displayZombies);
        })
        .on("error", function (error) {
          $("#txStatus").text(error);
        });
    }

    async function changeZombieName(zombieId, newName) {
      if (!newName.trim()) {
        $("#txStatus").text("Please enter a valid name.");
        return;
      }

      const zombie = await getZombieDetails(zombieId);

      if (zombie.level < 2) {
        $("#txStatus").text("You can only change the name for zombies at level 2 or above.");
        return;
      }

      $("#txStatus").text("Changing zombie name...");

      return cryptoZombies.methods.changeName(zombieId, newName)
        .send({ from: userAccount })
        .on("receipt", function (receipt) {
          $("#txStatus").text("Zombie name changed successfully!");
          getZombiesByOwner(userAccount).then(displayZombies);
        })
        .on("error", function (error) {
          $("#txStatus").text(error);
        });
    }



    function deleteZombie(zombieId) {
      $("#txStatus").text("Deleting zombie...");

      return cryptoZombies.methods.deleteZombie(zombieId)
        .send({ from: userAccount })
        .on("receipt", function (receipt) {
          $("#txStatus").text("Zombie deleted successfully!");
          getZombiesByOwner(userAccount).then(displayZombies);
        })
        .on("error", function (error) {
          $("#txStatus").text(error);
        });
    }



    function getZombieDetails(id) {
      return cryptoZombies.methods.zombies(id).call()
    }

    function zombieToOwner(id) {
      return cryptoZombies.methods.zombieToOwner(id).call()
    }

    function getZombiesByOwner(owner) {
      return cryptoZombies.methods.getZombiesByOwner(owner).call()
    }

    window.addEventListener('load', async () => {
      // Modern dapp browsers...
      if (window.ethereum) {
        window.web3 = new Web3(ethereum);
        try {
          // Request account access if needed
          const accounts = await ethereum.enable();
          // Acccounts now exposed
          userAccount = accounts[0];
          startApp()
        } catch (error) {
          // User denied account access...
        }
      }
      // Legacy dapp browsers...
      else if (window.web3) {
        window.web3 = new Web3(web3.currentProvider);
        // Acccounts always exposed
        userAccount = web3.eth.accounts[0];
        startApp()
      }
      // Non-dapp browsers...
      else {
        console.log('Non-Ethereum browser detected. You should consider trying MetaMask!');
      }
    });

    //the following code from Lesson 6, chapter 2 is obsolete
    //metamask no longer inject web3 since early 2021
    //window.addEventListener('load', function () {

    //    if (typeof web3 !== 'undefined') {
    //     web3js = new Web3(web3.currentProvider);
    //   } else {

    //  }


    //  startApp()

    //  }) 

    ethereum.on('accountsChanged', (accounts) => {
      window.location.reload();
    });

    ethereum.on('chainChanged', (chainId) => {
      window.location.reload();
    });


    createzombieButton.addEventListener('click', () => {
      const zombieName = prompt("Enter a name for your zombie:");
      if (zombieName) {
        createRandomZombie(zombieName);
      }
    });


    showZombieButton.addEventListener('click', () => {
      getZombiesByOwner(userAccount)
        .then(displayZombies);
        getAccounts();

    });

    levelupButton.addEventListener('click', async () => {
      const selectedZombieIds = [];

      document.querySelectorAll('.zombieCheckbox:checked').forEach((checkbox) => {
        selectedZombieIds.push(checkbox.value);
      });

      if (selectedZombieIds.length === 0) {
        $("#txStatus").text("Please select at least one zombie to level up.");
        return;
      }

      $("#txStatus").text("Leveling up selected zombies...");

      for (let zombieId of selectedZombieIds) {
        await cryptoZombies.methods.levelUp(zombieId)
          .send({ from: userAccount, value: web3.utils.toWei("0.001", "ether") })
          .on("receipt", function (receipt) {
            console.log(`Zombie ${zombieId} leveled up successfully!`);
          })
          .on("error", function (error) {
            console.error(`Error leveling up Zombie ${zombieId}:`, error);
          });
      }

      // Fetch latest data after level-up
      getZombiesByOwner(userAccount).then(displayZombies);
    });



    // changeDnaButton.addEventListener('click', async () => {
    //   const zombies = await getZombiesByOwner(userAccount);
    //   if (zombies.length > 0) {
    //     const zombieId = zombies[0];
    //     var newDna = Math.floor(Math.random() * 999999);
    //     newDna = newDna * 100;
    //     changeZombieDna(zombieId, newDna);
    //   } else {
    //     $("#txStatus").text("You have no zombies to modify.");
    //   }
    // });

    // changeNameButton.addEventListener('click', async () => {
    //   const newName = document.getElementById("newZombieName").value;
    //   const zombies = await getZombiesByOwner(userAccount);

    //   if (zombies.length > 0) {
    //     const zombieId = zombies[0]; // Change the first zombie's name (modify if needed)
    //     changeZombieName(zombieId, newName);
    //   } else {
    //     $("#txStatus").text("You have no zombies to rename.");
    //   }
    // });

    deleteZombieButton.addEventListener('click', async () => {
      const selectedZombieIds = [];
      document.querySelectorAll('.zombieCheckbox:checked').forEach((checkbox) => {
        selectedZombieIds.push(checkbox.value);
      });

      if (selectedZombieIds.length === 0) {
        $("#txStatus").text("Please select at least one zombie to delete.");
        return;
      }

      $("#txStatus").text("Deleting selected zombies...");

      for (let zombieId of selectedZombieIds) {
        await deleteZombie(zombieId);
      }

      getZombiesByOwner(userAccount).then(displayZombies);
    });


    createmultipleZombieButton.addEventListener('click', () => {
      const count = prompt("How many zombies do you want to create?", 1); // Prompt the user for the number
      if (count && count > 0) {
        createMultipleZombie(userAccount, count);
      } else {
        alert("Please enter a valid number.");
      }
    });


    //display zombie on nft 
    async function marketnfts() {
      debugger;
      let a = await cryptoZombies.methods.getZombiesOnSale().call();
      let b = await cryptoZombies.methods.getZombiesByOwner(userAccount).call();
      let c = a.filter(item => !b.includes(item));
      displaymarketZombies(c);
    }

    async function displaymarketZombies(ids) {
      $("#zombies").empty();

      for (let id of ids) {
        try {
          const zombie = await getZombieDetails(id);
          const saleDetails = await cryptoZombies.methods.zombiesForSale(id).call();
          const priceInEther = web3.utils.fromWei(saleDetails.price, "ether");
          let imageUrl = `https://robohash.org/${zombie.dna}?set=set1&size=150x150`;

          const zombieCard = $(`
        <div class="zombie-card bg-gray-900 text-gray-200 p-4 rounded-lg shadow-lg transition-all transform hover:scale-105">
          <img src="${imageUrl}" alt="Zombie Avatar" class="zombie-avatar mx-auto mb-4 rounded-full shadow-lg">
          <button class="fightButton btn bg-red-600 hover:bg-red-500 text-white font-bold py-2 px-4 rounded-lg transition duration-300 ease-in-out" style="background-color: red;margin-top: 10px;margin-bottom:10px" onclick="buyZombie(${id},${priceInEther})">Buy for ${priceInEther} ETH</button>
          <ul class="text-center space-y-2">
            <li><strong>Name:</strong> ${zombie.name}</li>
            <li><strong>DNA:</strong> ${zombie.dna}</li>
            <li><strong>Level:</strong> ${zombie.level}</li>
          </ul>
        </div>
      `);

          $("#zombies").append(zombieCard);

        } catch (error) {
          console.error(`Failed to fetch data for zombie ID ${id}:`, error);
        }
      }
    }

    async function buyZombie(zombieId, price) {
    try {
            const priceInWei = web3.utils.toWei(price.toString(), "ether");

            await cryptoZombies.methods
                .buyZombie(zombieId)
                .send({ from: userAccount, value: priceInWei })
                .on("receipt", function (receipt) {
                    console.log("Zombie purchased successfully!", receipt);
                    alert(`Successfully bought Zombie ID ${zombieId}!`);
                    
                    // Refresh the marketplace listing
                    document.getElementById("zombiesForSaleList").innerHTML = ""; // Clear existing
                    getZombiesOnMarketplace(); // Refresh the list
                })
                .on("error", function (error) {
                    console.error("Failed to buy zombie:", error);
                    alert("Error: Unable to purchase zombie. See console for details.");
                });
        } catch (error) {
            console.error("Error buying zombie:", error);
            alert("Failed to buy zombie. See console for details.");
        }
    }

    function transferZombie(zombieId, recipientAddress) {
    debugger;
    $("#txStatus").text("Transferring your zombie...");

    cryptoZombies.methods
        .transferFrom(userAccount, recipientAddress, zombieId)
        .send({ from: userAccount })
        .on("receipt", function (receipt) {
            $("#txStatus").text("Zombie transferred successfully!");
            getZombiesByOwner(userAccount).then(displayZombies);
        })
        .on("error", function (error) {
            $("#txStatus").text("Error transferring zombie: " + error.message);
        });
    }

    let availableAccounts = []; 
    async function getAccounts() {
        try {
            availableAccounts = await ethereum.enable(); 
            populateAccountDropdown(availableAccounts); 
        } catch (error) {
            console.log('User denied account access', error);
        }
    }

    function populateAccountDropdown(accounts) {
        const dropdown = document.querySelector('.recipientDropdown');
        dropdown.innerHTML = '';
        const option = document.createElement('option');
        option.textContent = "-- Select an Account --"; 
        dropdown.appendChild(option);
        accounts.forEach(account => {
            if(userAccount!=account){
                const option = document.createElement('option');
                option.value = account;
                option.textContent = account; 
                dropdown.appendChild(option);
            }
        });
    }

    document.querySelector('.transferZombieButton').addEventListener('click', () => {
    debugger;
    const selectedCheckboxes = document.querySelectorAll('.zombieCheckbox:checked'); // Get all checked checkboxes
    const recipientAddress = document.querySelector('.recipientDropdown').value;
    if (recipientAddress && recipientAddress!='-- Select an Account --') {
        selectedCheckboxes.forEach((checkbox) => {
            transferZombie(checkbox.getAttribute('data-id'), recipientAddress);
        });
    }else {
        alert('Please select a recipient account to transfer the zombie to.');
        getAccounts();
    }
});





  </script>
</body>

</html>